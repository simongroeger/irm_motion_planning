<!DOCTYPE html>
<html lang="en"> 
<head>
    <title>Motion Planning in RKHS</title>
    
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog Template">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">    
    <link rel="shortcut icon" href="favicon.ico"> 
    
    <!-- FontAwesome JS-->
	<script defer src="assets/fontawesome/js/all.min.js"></script>
    
    <!-- Plugin CSS -->
    <link rel="stylesheet" href="assets/plugins/highlight/styles/monokai-sublime.css">
    
    <!-- Theme CSS -->  
    <link id="theme-style" rel="stylesheet" href="assets/css/theme-1.css">
    
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head> 

<body>
    
    <header class="header text-center">	    
	    <h1 class="blog-name pt-lg-4 mb-0"><a class="no-text-decoration" >Simon's Blog</a></h1>
        
	    <nav class="navbar navbar-expand-lg navbar-dark" >
           
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div id="navigation" class="collapse navbar-collapse flex-column" >
				<div class="profile-section pt-3 pt-lg-4">
				    <img class="profile-image mb-3 rounded-circle mx-auto" src="assets/images/profile.jpg" alt="image" >			
					
					<div class="bio mb-3">Hi, my name is Simon Gröger. I am a student in my computer science master at TU Darmstadt and currently working on a  trajectory optimization project.<br></div><!--//bio-->
					<hr> 
				</div><!--//profile-section-->
				<div>
					<h1 class="blog-name pt-lg-4 mb-0"><a class="no-text-decoration" href="#" >Motion Planning in RKHS</a></h1>
					<h1 class="blog-name2 pt-lg-2 mb-0"><a class="no-text-decoration" href="#Introduction" >Introduction</a></h1>
					<h1 class="blog-name2 pt-lg-1 mb-0"><a class="no-text-decoration" href="#Math" >Math</a></h1>
					<h1 class="blog-name2 pt-lg-1 mb-0"><a class="no-text-decoration" href="#Implementation" >Implementation</a></h1>
					<h1 class="blog-name2 pt-lg-1 mb-0"><a class="no-text-decoration" href="#Experiments" >Experiments</a></h1>
					<h1 class="blog-name2 pt-lg-1 mb-0"><a class="no-text-decoration" href="#Insights" >Insights</a></h1>
					<h1 class="blog-name2 pt-lg-1 mb-0"><a class="no-text-decoration" href="#Conclusion" >Conclusion</a></h1>

				</div>
			</div>
		</nav>
    </header>
    
    <div class="main-wrapper">
	    
<article class="blog-post px-3 py-5 p-md-5">
	<div class="container single-col-max-width">


<!-- 
Actual content 
..........................................................................
..........................................................................
..........................................................................
..........................................................................
..........................................................................
..........................................................................
..........................................................................
-->

<header class="blog-post-header">
	<h1 class="title mb-2"><span id="Motion Planning in RKHS"></span>Motion Planning in RKHS</h1>
	<div class="meta mb-3"><span class="date">Intelligent Robotic Manipulation Project Lab II</span><span class="date">April 24 - Oktober 24</span><span class="date">Simon Gröger</span></div>
</header>
			    
<div class="blog-post-body">
<figure class="blog-banner">
	<img class="img-fluid" src="assets/images/heading.png" alt="image">
	<figcaption class="mt-2 text-center image-caption">Trajectory Optimization with a 3-link-robot</figcaption>
</figure>

<p></p>
In this project the goal is fast trajectory planning approach using the Reproducing Kernel Hilbert Space. 
This approach may lead to better results as the problem formulation has fewer local optima.
</p>

<h2 class="mt-5 mb-3"><span id="Introduction"></span>Introduction</h2>

<p>
	In motion planning trajectories are often defined in the Reproducing Kernel Hilbert Space (RKHS). The Trajectory is intialized in a straight line from start to goal configuration and then the cost of the trajectory is minimized using functional gradient descent thus avoiding obstacles.
</p>
<p>
	The trajectories are often defined in the Reproducing Kernel Hilbert Space (RKHS) and intialized in a straight line from start to goal configuration. Then the cost of the trajectory is minimized using functional gradient descent thus avoiding the obstacles
</p>

<h2 class="mt-5 mb-3"><span id="Math"></span>Math</h2>

<h4 class="mt-3 mb-3">Trajectory Formulation</h4>

<p> 

	Our trajectory, defined in RKHS, is defined between 0 and 1 and has a parameter matrix \(\alpha\), a kernel matrix K and an additional matrix J. 
	The kernel matrix uses the RBF kernel and the matrix J enables cross joint communication and optimization.
	The trajectory can be evaluated to the joint position for any timestep \(t\) with \(0 \le t \le 1\) using \[ evaluate(K, J, \alpha, t) = K(\cdot, t) \alpha J \]
	For the evaluation of the joint velocity, we define an additional kernelmatrix dK with \( dK = {\partial \over \partial t} K \) , such that it holds:  \[ {\partial \over \partial t} evaluate(K, J, \alpha, t) = evaluate(dK, J, \alpha, t) \]
	Thus the evaluation of the joint velocity is faster without having to differentiate each time.
	During the trajectory optimzation a finite fixed set of supporting points \( t_i \) for \( i \in \{1,...,n_{support}\} \) are used.
</p>	


<h4 class="mt-5 mb-3">Constraint Loss Formulation</h4>

<p>
The trajectory optimization problem consists of the loss of the trajectory in the cost map and multiple trajectory constraints.
The trajectory constraints define the distance of the start and end of the trajectory to the start and goal configuration of our environment. Additionally, the joint position is limited to a max and min position and the joint velocity is limited to an maximum absolute velocity.

Therefore the constraint formulation of our optimization problem is the following:

\[ \min_{\alpha} L(\alpha) = \sum_{i=1}^{n_{support}} costmap( fk(evaluate(K, J, \alpha, t_i) ) + { \lambda_{reg}  \over 2 } || evaluate(K, J, \alpha, \cdot) ||^2_2 \]
s.t. 
\[ { 1 \over 2 } || evaluate(K, J, \alpha, t_1)  - config_{start} ||^2_2 \le \epsilon_{position} \]
\[ { 1 \over 2 } || evaluate(K, J, \alpha, t_{n_{support}}) - config_{goal} ||^2_2 \le \epsilon_{position}  \]
\[ { 1 \over 2 } || evaluate(dK, J, \alpha, t_1) ||^2_2 \le \epsilon_{velocity}  \]
\[ { 1 \over 2 } || evaluate(dK, J, \alpha, t_{n_{support}}) ||^2_2 \le \epsilon_{velocity}  \]
\[ \forall i \in \{1,...,n_{support}\} : evaluate(K, J, \alpha, t_i) \le jointposition_{max}  \]
\[ \forall i \in \{1,...,n_{support}\} : evaluate(K, J, \alpha, t_i) \ge jointposition_{min}  \]
\[ \forall i \in \{1,...,n_{support}\} : | evaluate(dK, J, \alpha, t_i) | \le jointvelocity_{max}  \]
</p>
 

<h4 class="mt-5 mb-3"><span id="Lagragian Loss Formulation"></span>Lagragian Loss Formulation</h4>

<p>
During optimization the constraint loss is transformed to a Lagragian formulation and optimized using the Squared Penalty Method. This method iteratively minimizes the current loss and increases the Lagragian multiplier by an order of magnitude until all constraints are satified.
</p>

<p>
The Constraint Loss Formulaton is defined as

\[
\min_{\alpha} L(\alpha) = ObstacleLoss(\alpha) + \lambda_{sg} StartGoalLoss(\alpha) 
 + \lambda_{jl} JointLimitLoss(\alpha) + \lambda_{reg} || evaluate(K, J, \alpha, \cdot) ||^2_2   
\]
</p>
<br>
<br>
<p>
where the StartGoalLoss is defined as 
\[
StartGoalLoss(\alpha) = StartGoalPositionLoss(\alpha) + StartGoalVelocityLoss(\alpha)
\]
\[
StartGoalPositionLoss(\alpha) = {1 \over 2 } || evaluate(K, J, \alpha, t_1)  - config_{start} ||^2_2 + {1 \over 2 } || evaluate(K, J, \alpha, t_{n_{support}}) - config_{goal} ||^2_2
\]
\[
StartGoalVelocityLoss(\alpha) = {1 \over 2 } || evaluate(dK, J, \alpha, t_1) ||^2_2 + {1 \over 2 } || evaluate(dK, J, \alpha, t_{n_{support}}) ||^2_2
\]
</p>
<br>
<br>
<p>
Contrary to the StartGoalLoss, the JointLimitLoss is only applied if the limit is exceeded as thus is a bit more complicated
\[
JointLimitLoss(\alpha) = JointPositionLimitLoss(\alpha) + JointVelocityLimitLoss(\alpha)
\]
\[
JointPositionLimitLoss(\alpha) = \sum_{i=1}^{n_{support}} \sum_{j=1}^{n_{joints}} \left[ JointPositionLimitViolated(\alpha, i, j) \right] \left({ evaluate(K, J, \alpha, t_i)[j] - mean\_joint\_position \over std\_joint\_position } \right)^2
\]
\[
JointPositionLimitViolated(\alpha, i, j) = evaluate(K, J, \alpha, t_i)[j] \gt max\_joint\_position \vee evaluate(K, J, \alpha, t_i)[j] \lt min\_joint\_position 
\]
\[
mean\_joint\_position = 0.5 * (max\_joint\_position + min\_joint\_position)
\]
\[
std\_joint\_position = 0.5 * |max\_joint\_position - min\_joint\_position|
\]
</p>
<br>
<p>
\[
JointVelocityLimitLoss(\alpha) = \sum_{i=1}^{n_{support}} \sum_{j=1}^{n_{joints}}  \left[ JointVelocityLimitViolated(\alpha, i, j) \right] \left({ evaluate(dK, J, \alpha, t_i)[j] | \over max\_joint\_velocity } \right)^2
\]
\[
JointVelocityLimitViolated(\alpha, i, j) = |evaluate(dK, J, \alpha, t_i)[j] | \gt max\_joint\_velocity
\]
</p>
<br>
<br>
<p>
For the optimization process the obstacle loss is adjusted from the initial objective to overcome local optima and improve convergence.
The used obstacle loss combines the average and the maximum trajectory loss for the supporting points with a hyperparameter \( \lambda_{max\_cost} \) and is defined as follows:

\[ ObstacleLoss(\alpha) = 
         \lambda_{max\_cost} \max_{i} ObstacleLoss_{t_i}(\alpha)
  + (1 - \lambda_{max\_cost}) {1 \over n_{support}} \sum_{i=1}^{n_{support}} ObstacleLoss_{t_i}(\alpha)
\]
\[
ObstacleLoss_{t_i}(\alpha) = costmap( fk(evaluate(K, J, \alpha, t_i) )
\]
</p>


<h2 class="mt-5 mb-3"><span id="Implementation"></span>Implementation</h2>

<p>
The Trajectory Optimization is implemented in python with using jax and its numpy interface.
Jax has two features we want to utilize in this work:
The auto differentiation of functions can speedup the deelopment process as an adequate loss function can be designed without having to implement the analytical gradient each time to test it.
Jax is able to achieve very fast runtimes using its just-in-time compilation of python code and thus being able to do trajecotry optimization at 50hz.
</p>


<h4 class="mt-5 mb-3"><span id="Trajectory Initialization"></span>Trajectory Initialization</h4>

<p> 
We start the trajecotry initialization by choosing \( n_{support} \) supporting timesteps \( t_i \) between 0 and 1, which are usually equally distanced.
The Kernel matrix K and dK are initialized with the RBF kernel 
\[
K[i, j] = \exp\left( - \frac{(t_i - t_j)^2}{2 \cdot \text{rbf_var}^2} \right)
\]
and its derivative
\[
dK[i, j] = \frac{t_i - t_j}{\text{rbf_var}^2} * \exp\left( - \frac{(t_i - t_j)^2}{2 \cdot \text{rbf_var}^2} \right)
\]
with the variance rbf_var.
</p>
<p>
The matrix J is initialized as the addition of the identity matrix and random gaussian noise. The magnitude of the gaussian noise influences the cross joint communication and convergence speed. We achieved good robust results with a mean of 0.15.
</p>
<p>
The \(\alpha\) values are initialized by fitting the trajectory to 
\[
d(t) = \text{start_config} + (\text{goal_config} - \text{start_config}) * c(t) 
\]
with a function 
\[
c(t) = 6 * t^5 - 15 * t^4 + 10 * t^3
\]
where the function c was selected such that c(0)=0, c(1)=1, c'(0)=0, c'(1)=0, c''(0)=0, c''(1)=0 holds.
This initializes the trajectory to a straight line starting at start_config and finishing at goal_config while having zero velocity and acceleration at start and end.
</p>


<h4 class="mt-5 mb-3">Analytical Gradient</h4>

<p>
To speedup the trajectory optimization we do not use the automatic differentiation offered by jax but implemented the analytical gradient.
</p>
<p>
While the gradient computation of the various elements of our loss function is very straight-forward, the complexity of the Lagragian loss complicated the combination of sub-gradients to the final gradient.
During the implementation of the analytical gradient we used two main supporting tools:
<br>
The newest model of ChatGPT GPT-4o was able to implement the analytical gradient of a provided function with hardly any mistakes. 
<br>
By comparing the result of our implementation to the one of the jax auto differentiation we could iteratively ensure the correctness of our gradient computation for each sub function.
<br>
The combination of both tools made this part of this work a lot more pleasant and speedup the development significantly.
</p>

<h5 class="mt-5 mb-3">Optimizer</h5>

<p>
As described in the <a href="#Lagragian Loss Formulation">Largragian Loss Formulation Section</a>, we use a dual optimiation to find a minimal solution while holding the constraints.
For the dual optimization, especially with the lambda having different orders of magnitude, a fixed learning rate is not suitable to robustly find a solution.
Therefore we implemented two different optimizers for comparison.
<br>
The first optimizer uses regular Gradient Descent with a different learning rate for each outer iteratetion of the dual optimization to compensate the increase of the lambdas.
The second optimizer uses Backtracking Line Search Gradient Descent and thus uses an adaptive learning rate which does not need any other finetuning.
<br>
In practise the Backtracking Line Search Gradient Descent is faster and more robust than the regular Gradient Descent.
</p>




<h4 class="mt-5 mb-3">Algorithmic Pipeline</h4>
<h5 class="mt-3 mb-3">Pseudocode with linenumbers</h5>


<pre>
<code>
alpha, K, dK, J = initialize_trajectory()

while not constraint_fulfilled(alpha, K, dK, J) or n_outer==0 do

	while last_loss_reduction > eps do

		compute constraint_loss
		compute gradient
		lr = find optimal backtracking line search learning rate
		update trajectory: alpha = 

	
</code>
</pre>

<h2 class="mt-5 mb-3"><span id="Experiments"></span>Experiments</h2>

<h4 class="mt-3 mb-3">Environment</h4>

<p>
Our Environment is defined by a number of obstacles that need to be avoided and passed with maximal distance. We define a costmap with the 
\[
costfunction(x) = \sum_{i=1}^{n_{obstacles}} {0.8 \over 0.5 + 0.5 * ||x  - obstacle_i||^2_2 } 
\]
to get a convex optimization problem concerning a 2D point in the environment.
</p>

<figure class="blog-banner">
	<img class="img-fluid" src="assets/images/obstacles_costmap.png" alt="image">
	<figcaption class="mt-2 text-center image-caption">Obstacles of our environment with the resulting costmap and the robots start and goal configuration</figcaption>
</figure>

<p>
From this costmap we can derive a gradient field to maximize the distance to the obstacles
</p>

<figure class="blog-banner">
	<img class="img-fluid" src="assets/images/gradientfield.png" alt="image">
	<figcaption class="mt-2 text-center image-caption">Gradient Field of the Costmap</figcaption>
</figure>


<h4 class="mt-3 mb-3">Videos</h4>

TODO Videos: 
	optimization process
	final result


<h4 class="mt-3 mb-3">Runtime</h4>

TODO Runtime comparison (evtl jax profile)
	GD / BLSGD
	jax auto / analytical gradient
	runtime of parts of the loss function
	scalability for N_timesteps




<h2 class="mt-5 mb-3"><span id="Insights"></span>Insights</h2>

<h4 class="mt-3 mb-3">Complete Robot Obstacle Avoidance</h4>

<p>
Depending on the application not only the end-effector but the whole robot is placed in an environment with obstacles which are to avoid. 
In this case the cost fuction can be easily adjusted to minimize the cost at the position of all joints:
\[ 
ObstacleLoss_{t_i}(\alpha) = \sum_{j=1}^{n_{joints}} costmap( fk_j(evaluate(K, J, \alpha, t_i) ) 
\]
with \(fk_j\) being the forward kinematic for the joint \(j\) .
</p>


<h4 class="mt-5 mb-3">Lambda Max Cost</h4>

<p>
In our loss formulation we introduced the trajectory obstacle cost as the weighted sum of the average obstacle cost and the maximum obstacle cost using \( \lambda_{max\_cost} \).
\[ 
	ObstacleLoss(\alpha) = 
	\lambda_{max\_cost} \max_{i} ObstacleLoss_{t_i}(\alpha)
	+ (1 - \lambda_{max\_cost}) {1 \over n_{support}} \sum_{i=1}^{n_{support}} ObstacleLoss_{t_i}(\alpha)
\]
The reason is that the optimization of the trajectory is not convex anymore as some cross-joint and cross-timestep communication is required for the trajectory to converge to a global optimum and not be stuck in a local optima.
</p>
<p>
We assume the gradient of the part of the trajectory close to the obstacles is not big enough to overcome the local optima of the cost of the constraints and the smoothness cost, and thus the optimizer will find other ways to decrease the average trajectory cost without sufficiently increasing the distance to the nearest obstacles.

In the following figure you can see the results of different \( \lambda_{max\_cost} \) values and you can see that the optimization without the max cost ( \( \lambda_{max\_cost} = 0 \) ) does not reach a sufficient optimization of the trajectory.
</p>

<figure class="blog-banner">
	<img class="img-fluid" src="assets/images/lambda_max_cost.png" alt="image">
	<figcaption class="mt-2 text-center image-caption">Different Results for different \( \lambda_{max\_cost} \)</figcaption>
</figure>

<!-- 0.0  1.75 3.37  -->
<!-- 0.25 1.64 2.19   -->
<!-- 0.5  1.69 2.19   -->
<!-- 0.75 1.73 2.19   -->
<!-- 1.0  1.82 2.19   -->

<h4 class="mt-5 mb-3">Jacobian Matrix</h4>
<p>
In our trajectory formulation we use a matrix J to enable joint optimization with communication across different joints influencing each other.
The original paper sugested using the robotic Jacobian matrix as this matrix J. In our experiments the optimization did not find a suitable solution if we used the actual Jacobian matrix.
We think that the reason is that the magnitude of the entries of a robotic Jacobian very different. Naturally the elements for the first joint are larger than those of the last joints, which makes any optimization with the same learning rate impossible or at least very hard.
But as we have seen that random cross joint communication is speeding up the trajectory optimzation, we use a different matrix J, described in the <a href="#Trajectory Initialization">Trajectory Initialization Section</a>.
</p>

<h2 class="mt-5 mb-3"><span id="Conclusion"></span>Conclusion</h2>

While a trajectory formulated in the RKHS is easier to optimize the approach is still very sensitive to the hyper parameters.


TODO jax porofile recompilation



<!--
<h2 class="mt-5 mb-3">Code Block Example</h2>
<p>You can get more info at <a class="text-link" href="https://highlightjs.org/" target="_blank">https://highlightjs.org/</a>. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. </p>
<pre>
	<code>
function $initHighlight(block, cls) {
  try {
    if (cls.search(/\bno\-highlight\b/) != -1)
      return process(block, true, 0x0F) +
             ` class="${cls}"`;
  } catch (e) {
    /* handle exception */
  }
  for (var i = 0 / 2; i < classes.length; i++) {
    if (checkCondition(classes[i]) === undefined)
      console.log('undefined');
  }
}

export  $initHighlight;
	</code>
</pre>


<h2 class="mt-5 mb-3">Typography</h2>
<p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.</p>
<h5 class="my-3">Bullet Points:</h5>
<ul class="mb-5">
	<li class="mb-2">Lorem ipsum dolor sit amet consectetuer.</li>
	<li class="mb-2">Aenean commodo ligula eget dolor.</li>
	<li class="mb-2">Aenean massa cum sociis natoque penatibus.</li>
</ul>
<ol class="mb-5">
	<li class="mb-2">Lorem ipsum dolor sit amet consectetuer.</li>
	<li class="mb-2">Aenean commodo ligula eget dolor.</li>
	<li class="mb-2">Aenean massa cum sociis natoque penatibus.</li>
</ol>
<h5 class="my-3">Quote Example:</h5>
<blockquote class="blockquote m-lg-5 py-3   ps-4 px-lg-5">
	<p class="mb-2">You might not think that programmers are artists, but programming is an extremely creative profession. It's logic-based creativity.</p>
	<footer class="blockquote-footer mt-0">John Romero</footer>
</blockquote>

<h5 class="my-3">Table Example:</h5>
<table class="table table-striped my-5">
	<thead>
		<tr>
			<th scope="col">#</th>
			<th scope="col">First</th>
			<th scope="col">Last</th>
			<th scope="col">Handle</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">1</th>
			<td>Mark</td>
			<td>Otto</td>
			<td>@mdo</td>
		</tr>
		<tr>
			<th scope="row">2</th>
			<td>Jacob</td>
			<td>Thornton</td>
			<td>@fat</td>
		</tr>
		<tr>
			<th scope="row">3</th>
			<td>Larry</td>
			<td>the Bird</td>
			<td>@twitter</td>
		</tr>
	</tbody>
</table>

<h5 class="mb-3">Embed A Tweet:</h5>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">1969:<br>-what&#39;re you doing with that 2KB of RAM?<br>-sending people to the moon<br><br>2017:<br>-what&#39;re you doing with that 1.5GB of RAM?<br>-running Slack</p>&mdash; I Am Devloper (@iamdevloper) <a href="https://twitter.com/iamdevloper/status/926458505355235328?ref_src=twsrc%5Etfw">November 3, 2017</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>



<h2 class="mt-5 mb-3">Video Example</h2>
<p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. </p>

<div class="ratio ratio-16x9">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/1nxSE0R27Gg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>					
</div>

</div>
 -->
				
	<nav class="blog-nav nav nav-justified my-5">
		<a class="nav-link-top nav-item nav-link rounded" href="#">Back to Start<i class="arrow-prev fas fa-long-arrow-alt-up"></i><i class="arrow-next fas fa-long-arrow-alt-up"></i></a>
	</nav>
	
</div><!--//container-->
</article>
	
	
<footer class="footer text-center py-2 theme-bg-dark">
	
	<!--/* This template is free as long as you keep the footer attribution link. If you'd like to use the template without the attribution link, you can buy the commercial license via our website: themes.3rdwavemedia.com Thank you for your support. :) */-->
	<small class="copyright">Blog based on template by <a href="https://themes.3rdwavemedia.com" target="_blank">Xiaoying Riley</a></small>
	
</footer>

</div><!--//main-wrapper-->
    

        
       
<!-- Javascript -->          
<script src="assets/plugins/popper.min.js"></script> 
<script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script> 

<!-- Page Specific JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>

<!-- Custom JS -->
<script src="assets/js/blog.js"></script> 


</body>
</html> 

